#[doc = "Register `CR1` reader"]
pub type R = crate::R<CR1_SPEC>;
#[doc = "Register `CR1` writer"]
pub type W = crate::W<CR1_SPEC>;
#[doc = "Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CEN_A {
    #[doc = "0: Counter disabled"]
    B_0x0 = 0,
    #[doc = "1: Counter enabled"]
    B_0x1 = 1,
}
impl From<CEN_A> for bool {
    #[inline(always)]
    fn from(variant: CEN_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CEN` reader - Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs."]
pub type CEN_R = crate::BitReader<CEN_A>;
impl CEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> CEN_A {
        match self.bits {
            false => CEN_A::B_0x0,
            true => CEN_A::B_0x1,
        }
    }
    #[doc = "Counter disabled"]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == CEN_A::B_0x0
    }
    #[doc = "Counter enabled"]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == CEN_A::B_0x1
    }
}
#[doc = "Field `CEN` writer - Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs."]
pub type CEN_W<'a, REG> = crate::BitWriter<'a, REG, CEN_A>;
impl<'a, REG> CEN_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Counter disabled"]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(CEN_A::B_0x0)
    }
    #[doc = "Counter enabled"]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(CEN_A::B_0x1)
    }
}
#[doc = "Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum UDIS_A {
    #[doc = "0: UEV enabled. The Update (UEV) event is generated by one of the following events:"]
    B_0x0 = 0,
    #[doc = "1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    B_0x1 = 1,
}
impl From<UDIS_A> for bool {
    #[inline(always)]
    fn from(variant: UDIS_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `UDIS` reader - Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values."]
pub type UDIS_R = crate::BitReader<UDIS_A>;
impl UDIS_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> UDIS_A {
        match self.bits {
            false => UDIS_A::B_0x0,
            true => UDIS_A::B_0x1,
        }
    }
    #[doc = "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == UDIS_A::B_0x0
    }
    #[doc = "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == UDIS_A::B_0x1
    }
}
#[doc = "Field `UDIS` writer - Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values."]
pub type UDIS_W<'a, REG> = crate::BitWriter<'a, REG, UDIS_A>;
impl<'a, REG> UDIS_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "UEV enabled. The Update (UEV) event is generated by one of the following events:"]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(UDIS_A::B_0x0)
    }
    #[doc = "UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller."]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(UDIS_A::B_0x1)
    }
}
#[doc = "Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum URS_A {
    #[doc = "0: Any of the following events generates an update interrupt or DMA request if enabled. These events can be:"]
    B_0x0 = 0,
    #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled."]
    B_0x1 = 1,
}
impl From<URS_A> for bool {
    #[inline(always)]
    fn from(variant: URS_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `URS` reader - Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller"]
pub type URS_R = crate::BitReader<URS_A>;
impl URS_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> URS_A {
        match self.bits {
            false => URS_A::B_0x0,
            true => URS_A::B_0x1,
        }
    }
    #[doc = "Any of the following events generates an update interrupt or DMA request if enabled. These events can be:"]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == URS_A::B_0x0
    }
    #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request if enabled."]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == URS_A::B_0x1
    }
}
#[doc = "Field `URS` writer - Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller"]
pub type URS_W<'a, REG> = crate::BitWriter<'a, REG, URS_A>;
impl<'a, REG> URS_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Any of the following events generates an update interrupt or DMA request if enabled. These events can be:"]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(URS_A::B_0x0)
    }
    #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request if enabled."]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(URS_A::B_0x1)
    }
}
#[doc = "One-pulse mode\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OPM_A {
    #[doc = "0: Counter is not stopped at update event"]
    B_0x0 = 0,
    #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)."]
    B_0x1 = 1,
}
impl From<OPM_A> for bool {
    #[inline(always)]
    fn from(variant: OPM_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `OPM` reader - One-pulse mode"]
pub type OPM_R = crate::BitReader<OPM_A>;
impl OPM_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> OPM_A {
        match self.bits {
            false => OPM_A::B_0x0,
            true => OPM_A::B_0x1,
        }
    }
    #[doc = "Counter is not stopped at update event"]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == OPM_A::B_0x0
    }
    #[doc = "Counter stops counting at the next update event (clearing the CEN bit)."]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == OPM_A::B_0x1
    }
}
#[doc = "Field `OPM` writer - One-pulse mode"]
pub type OPM_W<'a, REG> = crate::BitWriter<'a, REG, OPM_A>;
impl<'a, REG> OPM_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Counter is not stopped at update event"]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(OPM_A::B_0x0)
    }
    #[doc = "Counter stops counting at the next update event (clearing the CEN bit)."]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(OPM_A::B_0x1)
    }
}
#[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ARPE_A {
    #[doc = "0: TIMx_ARR register is not buffered."]
    B_0x0 = 0,
    #[doc = "1: TIMx_ARR register is buffered."]
    B_0x1 = 1,
}
impl From<ARPE_A> for bool {
    #[inline(always)]
    fn from(variant: ARPE_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `ARPE` reader - Auto-reload preload enable"]
pub type ARPE_R = crate::BitReader<ARPE_A>;
impl ARPE_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> ARPE_A {
        match self.bits {
            false => ARPE_A::B_0x0,
            true => ARPE_A::B_0x1,
        }
    }
    #[doc = "TIMx_ARR register is not buffered."]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == ARPE_A::B_0x0
    }
    #[doc = "TIMx_ARR register is buffered."]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == ARPE_A::B_0x1
    }
}
#[doc = "Field `ARPE` writer - Auto-reload preload enable"]
pub type ARPE_W<'a, REG> = crate::BitWriter<'a, REG, ARPE_A>;
impl<'a, REG> ARPE_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "TIMx_ARR register is not buffered."]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(ARPE_A::B_0x0)
    }
    #[doc = "TIMx_ARR register is buffered."]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(ARPE_A::B_0x1)
    }
}
#[doc = "UIF status bit remapping\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum UIFREMAP_A {
    #[doc = "0: No remapping. UIF status bit is not copied to TIMx_CNT register bit 31."]
    B_0x0 = 0,
    #[doc = "1: Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31."]
    B_0x1 = 1,
}
impl From<UIFREMAP_A> for bool {
    #[inline(always)]
    fn from(variant: UIFREMAP_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `UIFREMAP` reader - UIF status bit remapping"]
pub type UIFREMAP_R = crate::BitReader<UIFREMAP_A>;
impl UIFREMAP_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> UIFREMAP_A {
        match self.bits {
            false => UIFREMAP_A::B_0x0,
            true => UIFREMAP_A::B_0x1,
        }
    }
    #[doc = "No remapping. UIF status bit is not copied to TIMx_CNT register bit 31."]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == UIFREMAP_A::B_0x0
    }
    #[doc = "Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31."]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == UIFREMAP_A::B_0x1
    }
}
#[doc = "Field `UIFREMAP` writer - UIF status bit remapping"]
pub type UIFREMAP_W<'a, REG> = crate::BitWriter<'a, REG, UIFREMAP_A>;
impl<'a, REG> UIFREMAP_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No remapping. UIF status bit is not copied to TIMx_CNT register bit 31."]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(UIFREMAP_A::B_0x0)
    }
    #[doc = "Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31."]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(UIFREMAP_A::B_0x1)
    }
}
#[doc = "Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DITHEN_A {
    #[doc = "0: Dithering disabled"]
    B_0x0 = 0,
    #[doc = "1: Dithering enabled"]
    B_0x1 = 1,
}
impl From<DITHEN_A> for bool {
    #[inline(always)]
    fn from(variant: DITHEN_A) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DITHEN` reader - Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset."]
pub type DITHEN_R = crate::BitReader<DITHEN_A>;
impl DITHEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> DITHEN_A {
        match self.bits {
            false => DITHEN_A::B_0x0,
            true => DITHEN_A::B_0x1,
        }
    }
    #[doc = "Dithering disabled"]
    #[inline(always)]
    pub fn is_B_0x0(&self) -> bool {
        *self == DITHEN_A::B_0x0
    }
    #[doc = "Dithering enabled"]
    #[inline(always)]
    pub fn is_B_0x1(&self) -> bool {
        *self == DITHEN_A::B_0x1
    }
}
#[doc = "Field `DITHEN` writer - Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset."]
pub type DITHEN_W<'a, REG> = crate::BitWriter<'a, REG, DITHEN_A>;
impl<'a, REG> DITHEN_W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Dithering disabled"]
    #[inline(always)]
    pub fn B_0x0(self) -> &'a mut crate::W<REG> {
        self.variant(DITHEN_A::B_0x0)
    }
    #[doc = "Dithering enabled"]
    #[inline(always)]
    pub fn B_0x1(self) -> &'a mut crate::W<REG> {
        self.variant(DITHEN_A::B_0x1)
    }
}
impl R {
    #[doc = "Bit 0 - Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs."]
    #[inline(always)]
    pub fn CEN(&self) -> CEN_R {
        CEN_R::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values."]
    #[inline(always)]
    pub fn UDIS(&self) -> UDIS_R {
        UDIS_R::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller"]
    #[inline(always)]
    pub fn URS(&self) -> URS_R {
        URS_R::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - One-pulse mode"]
    #[inline(always)]
    pub fn OPM(&self) -> OPM_R {
        OPM_R::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 7 - Auto-reload preload enable"]
    #[inline(always)]
    pub fn ARPE(&self) -> ARPE_R {
        ARPE_R::new(((self.bits >> 7) & 1) != 0)
    }
    #[doc = "Bit 11 - UIF status bit remapping"]
    #[inline(always)]
    pub fn UIFREMAP(&self) -> UIFREMAP_R {
        UIFREMAP_R::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bit 12 - Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset."]
    #[inline(always)]
    pub fn DITHEN(&self) -> DITHEN_R {
        DITHEN_R::new(((self.bits >> 12) & 1) != 0)
    }
}
impl W {
    #[doc = "Bit 0 - Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs."]
    #[inline(always)]
    pub fn CEN(&mut self) -> CEN_W<'_, CR1_SPEC> {
        CEN_W::new(self, 0)
    }
    #[doc = "Bit 1 - Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values."]
    #[inline(always)]
    pub fn UDIS(&mut self) -> UDIS_W<'_, CR1_SPEC> {
        UDIS_W::new(self, 1)
    }
    #[doc = "Bit 2 - Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller"]
    #[inline(always)]
    pub fn URS(&mut self) -> URS_W<'_, CR1_SPEC> {
        URS_W::new(self, 2)
    }
    #[doc = "Bit 3 - One-pulse mode"]
    #[inline(always)]
    pub fn OPM(&mut self) -> OPM_W<'_, CR1_SPEC> {
        OPM_W::new(self, 3)
    }
    #[doc = "Bit 7 - Auto-reload preload enable"]
    #[inline(always)]
    pub fn ARPE(&mut self) -> ARPE_W<'_, CR1_SPEC> {
        ARPE_W::new(self, 7)
    }
    #[doc = "Bit 11 - UIF status bit remapping"]
    #[inline(always)]
    pub fn UIFREMAP(&mut self) -> UIFREMAP_W<'_, CR1_SPEC> {
        UIFREMAP_W::new(self, 11)
    }
    #[doc = "Bit 12 - Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset."]
    #[inline(always)]
    pub fn DITHEN(&mut self) -> DITHEN_W<'_, CR1_SPEC> {
        DITHEN_W::new(self, 12)
    }
}
#[doc = "TIM7 control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CR1_SPEC;
impl crate::RegisterSpec for CR1_SPEC {
    type Ux = u16;
}
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"]
impl crate::Readable for CR1_SPEC {}
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"]
impl crate::Writable for CR1_SPEC {
    type Safety = crate::Safe;
}
#[doc = "`reset()` method sets CR1 to value 0"]
impl crate::Resettable for CR1_SPEC {}
